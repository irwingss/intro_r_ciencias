---
title: "Introducción a R para Ciencias C1-S1"
Subtitle: "Programa de Certificación Especializado Data Science: Estadística y Análisis de Datos en R"
Author: "Instructor: Irwing S. Saldaña"
output: distill::distill_article
editor_options: 
  chunk_output_type: console
---

# 1. Variables: Tipos (CLASES)

En un estudio se pretende revisar cuál es la medida promedio de tiempo que tarda una reacción enzimática. La variable `tiempo de reacción` es una variable numérica continua. De los 10 experimentos se obtuvieron las siguientes mediciones en segundos:

`9.9, 10.2, 10.3, 11.0, 10.8, 9.7, 8.2, 9.4, 9.6, 10.7`

### **1.1. ¿Cómo podríamos almacenar los valores en R?**

Esta sección busca que conozcas lo tipos de variables u objetos, sin importar su estructura, pero **es imposible evitar adelantaremos** un poco sobre la temática de estructuras, y comenzaremos hablando de la estructura de datos más sencilla en R: los vectores.

```{r}
# Vectores:
tReaccion <- c(9.9, 10.2, 10.3, 11.0, 10.8, 9.7, 8.2, 9.4, 9.6, 10.7)
tReaccion
```

### 1.2. Conozcamos formalmente los demás tipos de variables

```{r}
# Numeric (CON DECIMALES)
num <- c(2010,2011,2012,2013,2014,2016)
num2 <- c(1.2,1.3,1.4)

# Integer
# Números enteros
int <- c(2010L,2011L,2012L,2013L,2014L,2015L)
int2 <- 10:20
int2

# Character
"amarillo"
"Las flores son bonitas"

char <- c("Trujillo",'Lima',"Iquitos",'Puno')

"2000"

char2 <- c("12","13")

char2

# Logical
TRUE
FALSE

log <- c(TRUE, TRUE, FALSE, FALSE)
log

```

### **1.3. Reemplazar el contenido de una variable**

```{r}
log2 <- c(T,F,T,F,T,F,T,F)
log2

```

# 2. Variables: Estructuras de datos

Pueden ser de la estructura:

-   vectores

-   factores

-   listas

-   matrices

-   data.frames

-   tibbles

-   arrays

-   **Especiales:** objetos resultantes de funciones específicas (rpart, cluster, dendrogram, dist, etc.)

### 2.1. Preguntas lógicas a R: grupo de funciones `is.()`

```{r, eval=FALSE}
# Podemos preguntar:
# si un objeto es de una ESTRUCTURA de datos específica
is.vector(tReaccion)
is.matrix(tReaccion)
is.data.frame(tReaccion)
is.list(tReaccion)
# is_tibble() EN TIDYVERSE

# si es de una CLASE específica
is.character()
is.numeric()
is.integer()
is.logical()

# o hacer una pregunta genérica
is()
is(tReaccion)

data("iris")
is(iris)

```

### 2.2. Listado de preguntas lógicas frecuentes

```{r, eval=FALSE}
# Para preguntar:
# si una variable es de una CLASE en particular
is.character()
is.integer()
is.numeric()

# si es de una ESTRUCTURA en particular
is.vector()
is.factor()
is.list()
is.matrix()
is.data.frame()

# o hacer una pregunta genérica
is()
```

### **2.3. Conoce las funciones del grupo `as.()`**: Coerción

Como ya hemos visto, `TRUE` y `FALSE` son palabras lógicas y no requieren de tener comillas para ser interpretadas como verdadero y falso. Ahora, aprendamos el uso de las funciones del grupo `as.()`

```{r, eval=FALSE}
# Funciones del grupo as()
as.integer()
as.numeric()
as.character()
as.logical()

# Apliquemos coerción
char <- c("Trujillo",'Lima',"Iquitos",'Puno',"Trujillo",
          "Trujillo",'Puno','Puno','Puno','Puno','Puno',
          "Iquitos","Iquitos",'Lima')

is.vector(char)
is.factor(char)

char2 <- as.factor(char)

is.vector(char2)
is.factor(char2)

char
char2
levels(char2)

num
num <- as.character(num)
```

## 2.4. Vectores

```{r}
# Crea un vector numérico y guardalo con el nombre vect.n
vect.n <- c(45,10,15,25,13)

# Crea un vector de caracteres y guardalo con el nombre vect.ch
vect.ch <- c("A","B","C","D","E")

# Crea un vector de lógico y guardalo con el nombre vect.l
vect.l <- c(T,T,T,F,F)

```

Es muy útil aprender a manejar funciones que nos permitan crear vectores especiales de manera sencilla. Conoce las funciones `rep()`, `seq()`, `paste()` y `paste0()`.

```{r}
# Aprendamos a usar la función de repetición
# rep(LO QUE QUIERO REPETIR, LA CANTIDAD DE VECES)
rep("A",10)
rep(15,100)
rep(c(T,F), 5)
rep(c("Anita","Maria","Juan"), 5)

rep(c("Anita","Maria","Juan"), rep(5,3))
c(rep("Anita",5), rep("Maria",5), rep("Juan",5))

# Aprendamos a usar la función de secuencias
# seq(INICIO, FINAL, CADA CUANTOS/LONGITUD)
1:10
seq(1,10,by=2)
seq(1,10,length=20)

# Aprendamos a usar la función paste() y paste0()
paste("Sitio", 1:20)
paste("Muestra", 1:100)

paste0("Sitio", 1:20)
paste0("Sitio_", 1:20)

# Ambos son identicos
paste0("Sitio ", 1:20)
paste("Sitio", 1:20)
```

A veces es necesario crear un vector vacío. Esto es necesario cuando queremos rellenarlo luego con los resultados de un loop.

```{r}
# Crea un vector vacío de clase numeric, character y logical
vect_vacio <- vector(mode="numeric", length=20)
vect_vacio <- vector("numeric", 20)
vect_vacio

vector("character", 20)
vector("logical", 20)

```

## 2.5. Factores

Los factores son importantísimos para definir niveles de análisis, por ejemplo, en un ANOVA, o para colorear un gráfico por categorías, etc. **Son formas especiales de vectores** de clase `character` (es decir: son variables categóricas)

```{r}
# Crea este vector llamado talla
talla <- c(rep("Alto",5),rep("Bajo",10))

# Convierte el vector a factor con una función as()
tallaF <- as.factor(talla)

# Crea un factor con factor()
tallaF <- factor(talla)
levels(tallaF)

# Reordenar niveles de un factor
levels(tallaF)

tallaF2 <- factor(talla, levels = c("Bajo","Alto"))
levels(tallaF2)

# Cambiar el nombre de los niveles
levels(tallaF)
tallaF3 <- factor(tallaF, labels= c("Alto"="A","Bajo"="B"))
levels(tallaF3)
tallaF3

#Niveles de un vector
help(factor)
args(factor) #ARGUMENTOS

```

## 2.6. Matrices

```{r}
# Crear matrices a partir de un vector
matrix(1:100)
matrix(1:100, ncol=5, nrow=20)

# Las matrices se autocompletan (Ver columna 6)
matrix(1:100, ncol=6, nrow=20) 

mat <- matrix(1:100, ncol=5, nrow=20, byrow=TRUE)

# Matrices con nombres de las dimensiones
matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE,
               dimnames = list(c("row1", "row2"),
                               c("C.1", "C.2", "C.3")))

# Crear una matriz vacía
mat.vacia <- matrix(NA, ncol=5, nrow=20)
```

## 2.7. Data.Frame

```{r}
# Crear data frames a partir de un vector
data.frame(vect.n, vect.ch, vect.l)
DF <- data.frame(numeros = vect.n, texto = vect.ch, logico = vect.l)
colnames(DF)
rownames(DF)

rownames(DF) <- paste0("Sitio", 1:5)

View(DF)
rownames(DF) 

# ¿Siempre deben tener la misma longitud los vectores de una DF?
data.frame(c(vect.n, 100,101,102,103), vect.ch, vect.l)
data.frame(c(vect.n, 100,101,102,103), vect.ch, vect.l)

fix(num)
fix(DF)

str(DF)

```

## 2.8. Listas

```{r}
# Lista de talla, vect.ch, vect.l, sin indicar nombres
milista <- list(vect.ch, vect.l, vect.n, DF, mat, talla.f)

# Lista con nombres
library(tidyverse)
milista2 <- lst(vect.ch, vect.l, vect.n, DF, mat, talla.f)
```

# **3. Indexación de Variables**

Indexar significa seleccionar elementos de una variable u objeto. Como hemos visto, tenemos diferentes estructuras de datos y una variable puede estar construida con cualquiera de ellos. Aprenderemos a seleccionar o indexar usando operadores específicos para cada estructura de datos.

Operadores de indexación:

-   Corchetes: [ ]

-   Corchetes dobles: [[ ]]

-   Dólar: $

### 3.1. Objetos 1D: Vectores, Factores

```{r}
# Indexar la posición 4 del vector talla
talla[9]
talla[4]

# Indexar la posición 1,5,8 del vector talla
talla[c(4,9)]

# Indexar la posición del 2:10 del vector talla
talla[4:9]
talla[2:10]

# Indexar factor
is.factor(tallaF2)
tallaF2[c(1,4,5)]
as.vector(tallaF2[c(1,4,5)])
```

### 3.2. Objetos 2D: Matrices, Data frames y Tibbles

```{r}
# Cargar una base de datos de trabajo llamada iris
data("iris")

# Visualizar iris
View(iris)

# Indexar el elemento de la posición fila 30, columa 4
iris[30,4]

# Indexar toda la columna 4
iris[,4]

length(iris[,4]) # numero de filas
length(iris) # numero de columnas

nrow(iris)
ncol(iris)

# Indexar toda la fila 72
is.vector(iris[72,])
is.data.frame(iris[72,])
is.vector(as.vector(iris[72,]))
 
fila  <- iris[72,]
fila <- as.vector(fila)
is.vector(fila)

# Indexar con simbolo de dólar
iris$Petal.Length
sp <- iris$Species
is.factor(sp)

# Ver los atributos de una base de datos 2D
attributes(iris)
attributes(milista2)
attributes(vect.ch)

# Indexar con nombre de columna 
# Y aprendamos a usar apply() y which()

# --- apply()
vect.n
mean(vect.n)

# Manera: 1 para aplicar como filas,
# o puede ser 2 para aplicar como columnas
# FUNCION SIN PARÉNTESIS EN EL TERCER ARGUMENTO
apply(iris[,1:4], 2, mean)
is.vector(apply(iris[,1:4], 2, mean))

# Calcular promedio de las filas de la 10 a la 20
iris2 <- iris[,-c(1,5)]
apply(iris2[10:20,], 1, mean)

# lapply()
# vapply()

# --- which() 
iris[,"Species"]

colnames(iris) == "Species"

which(colnames(iris) == "Species")

# Graficar con plot() e indexación con $
plot(iris$Petal.Length, iris$Sepal.Length)

# Indexar con la función with()
colnames(iris)
names(iris)
with(iris, plot(Petal.Length, Sepal.Length))

```

### 3.3. Objetos nD: Listas

```{r}
# Indexar una lista sin nombres SIEMPRE CON DOBLE CORCHETE
milista


# Indexar una lista con nombres SIEMPRE CON DOLAR
milista2$vect.ch
milista2$DF

# Ver los atributos de una lista
attributes(milista2)
str(milista2)

```

# **4. Operadores lógicos**

```{r}
# Crear tres condición lógica y guardarlas como a, b y c
a <- 3 > 10
b <- 5 < 10
c <- 6 != 10

a <- F
b <- T
c <- T

# Ejecutemos algunas condiciones lógicas

a & b
b & c

TRUE & TRUE
TRUE & FALSE
FALSE & TRUE 
FALSE & FALSE 

TRUE | TRUE
TRUE | FALSE
FALSE |TRUE 
FALSE | FALSE 

filter(iris, Species == "setosa" & Sepal.Length > 5 & Petal.Length > 5)
filter(iris, Species == "setosa" | Sepal.Length > 5)
filter(iris, Species != "setosa")

# con subset
subset(iris$Sepal.Length, iris$Species=="setosa")
subset(iris, iris$Species=="setosa")

```

# **5. Valores Perdidos**

```{r}
# Activemos otra base de datos
data("airquality")
View(airquality)

# Ubicar valores NA en iris y airquality
# TRUE significa es valor NA, FALSE no es NA
is.na(airquality)

# Sumar cuantos valores NA hay en iris y airquality
sum(is.na(airquality))

# Sumar cuantos valores NA hay en cada columna de airquality
colSums(airquality)
colSums(airquality, na.rm=TRUE)

colSums(is.na(airquality))

# Ubicar exactamente dónde están los NA en airquality
which(is.na(airquality), arr.ind=TRUE)

# Identificar las filas que no tiene NA (TRUE) y las 
# que tiene NA (FALSE) en airquality 
index <- !complete.cases(airquality)
airquality[index,]

# Elimina las filas que contienen NA
index2 <- complete.cases(airquality)
airquality[index2,]

na.omit(airquality)

# Nueva base sin NA
air.sin.na <- na.omit(airquality)

# Reemplazar la base original con la base sin NA
airquality <- na.omit(airquality)
```
