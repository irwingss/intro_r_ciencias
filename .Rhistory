openxlsx::read.xlsx("bases/tabla2.xlsx")%>%
xtable(format = "pandoc", caption = 'Operaciones matemáticas en R. Estos procedimientos matemáticos vienen predefinidos como ordenes denominadas "Funciones"')
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
?kable_styling
?kableExtra::kable_styling
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
openxlsx::read.xlsx("bases/tabla4.xlsx")%>%
kable(format = "pandoc", caption = 'Cincuenta funciones básicas útiles en R.', format = "pipe")
library(tidyverse)
openxlsx::read.xlsx("bases/tabla4.xlsx")%>%
kable(format = "pandoc", caption = 'Cincuenta funciones básicas útiles en R.', format = "pipe")
library(kableExtra)
openxlsx::read.xlsx("bases/tabla4.xlsx")%>%
kable(format = "pandoc", caption = 'Cincuenta funciones básicas útiles en R.', format = "pipe")
openxlsx::read.xlsx("bases/tabla4.xlsx")%>%
kable(format = "pipe", caption = 'Cincuenta funciones básicas útiles en R.')
openxlsx::read.xlsx("bases/tabla4.xlsx")%>%
kable(format = "pipe", caption = 'Cincuenta funciones básicas útiles en R.') %>% View()
openxlsx::read.xlsx("bases/tabla4.xlsx")%>%
kable(format = "pipe", caption = 'Cincuenta funciones básicas útiles en R.') %>% Viewer()
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
#Load the owl data
Owls <- read.table(file.choose(), header=TRUE)
names(Owls)
str(Owls)
Owls$NCalls <- Owls$SiblingNegotiation
#Section 2.1
#Fig 2.2
library(mgcv)
G1 <- gamm(NCalls ~ FoodTreatment + s(ArrivalTime),
random = list(Nest =~ 1),
data = Owls)
plot(G1$gam, cex.lab = 1.5)
plot(G1$lme, cex.lab = 1.5)
plot(G1$gam, cex.lab = 1.5)
#Section 2.3 Data exploration
table(Owls$Nest)
plot(table(Owls$Nest), type = "h")
#Section 2.3 Data exploration
table(Owls$Nest)
plot(table(Owls$Nest), type = "h")
Owls2 <- Owls[Owls$Nest!="Chevroux" &
Owls$Nest!="Forel" &
Owls$Nest!="GDLV" &
Owls$Nest!="SEvaz",]
Owls2$Nest <- factor(Owls2$Nest)
#Figure 2.4
plot.design(NCalls ~ FoodTreatment + SexParent + Nest ,
data = Owls2,
cex.lab = 1.5)
#Figure 2.4
plot.design(NCalls ~ FoodTreatment + SexParent + Nest ,
data = Owls2,
cex.lab = 1.5)
#Figure 2.4
plot.design(NCalls ~ FoodTreatment + SexParent + Nest ,
data = Owls2,
cex.lab = 1.5)
#Figure 2.5
interaction.plot(Owls2$FoodTreatment, Owls2$SexParent,
Owls2$NCalls, xlab="FoodTreatment",
ylab="Sibbling negotiation",
cex.lab = 1.5)
#Figure 2.6
library(lattice)
xyplot(NCalls ~ ArrivalTime | SexParent * FoodTreatment,
data = Owls2, cex.lab = 1.5,
ylab = "Sibbling negotiation", xlab = "Arrival time (hours)",
panel=function(x, y){
panel.grid(h = -1, v = 2)
panel.points(x, y, col = 1)
panel.loess(x, y, span = 0.3, col = 1, lwd = 2)})
#Figure 2.7
xyplot(Ycoord ~ Xcoord, aspect = "iso", col = 1,
xlab = "X coordinate",
ylab = "Y coordinate",
data = Owls2,
pch = 16)
#Figure 2.8
xyplot(NCalls ~ ArrivalTime | Nest, type="h",
subset = (FoodTreatment == "Satiated"),
data = Owls2, col = 1)
#Figure 2.9
xyplot(NCalls ~ ArrivalTime | Nest, type="h",
subset = (FoodTreatment == "Deprived"),
data = Owls2, col = 1)
#Section 2.4
library(lme4)
Owls2$LogBroodSize <- log(Owls2$BroodSize)
M1 <- glmer(NCalls ~ SexParent * FoodTreatment +
SexParent * ArrivalTime +
offset(LogBroodSize) +
(1| Nest),
family = poisson, data = Owls2)
#See ongoing discussions on mixed modelling mailing list regarding
#warning messages
summary(M1)
E1 <- residuals(M1)
p1 <- length(fixef(M1)) + 1              #The +1 is due to the variance of the random effect
Overdisp1 <- sum(E1^2) / (nrow(Owls2) - p1)
Overdisp1
Overdisp1
#Section 2.4.3
##############################################################
#Simulate some data to illustrate the essential part of a GLMM
##############################################################
set.seed(12345)
#Choose N, alpha and beta
N <- 300
X<-runif(N,0,5)
alpha <- 3
beta  <- -1
#Simulate some Poisson data and plot it
eta <- alpha + beta * X
mu <- exp(eta)
Y <- rpois(N, lambda = mu)
plot(x=X, y=Y)
#Apply a Poisson GLM to see whether we get similar estimated values
M1 <- glm(Y ~ X, family = poisson)
summary(M1)
#Now simulate a random intercept a_i, and add it to the data.
#Also create a variable that we can use in the models for this random intercept
a1 <- rnorm(20, mean = 0, sd = 0.1)
a  <- rep(a1, each = 15)
RE <- rep(1:20, each = 15)
ShowWhatWeDo <- cbind(eta,mu,Y,a,RE)
head(ShowWhatWeDo,30)
#Now add the random intercept to the predictor function,
#and sample again Poisson data. These will be more noisy
eta1 <- alpha + beta * X + a
mu1 <- exp(eta1)
Y1 <- rpois(N, lambda = mu1)
plot(x=X, y=Y1)
plot(Y,Y1)
plot(x=X, y=Y1)
plot(Y,Y1)
#Now apply a random intercept GLMM with Poisson distribution
library(lme4)
M2 <- glmer(Y1 ~ X + (1|RE) , family = poisson)
summary(M2)
#Check for overdispersion
E2 <- resid(M2, type = "pearson")
N <- length(Y1)
p <- length(fixef(M2)) + 1
sum(E2^2) / (N - p)
#First apply this model on the Y1 data...and the
#estimated variance of Eps should be small!
Eps <- 1:length(Y1)
M3 <- glmer(Y1 ~ X + (1|RE) + (1|Eps) , family = poisson)
summary(M3)
E3 <- resid(M3, type = "pearson")
p3 <- length(fixef(M3)) + 2
sum(E3^2)/(N-p3)
#That looks all ok
#And apply a likelihood ratio test...hopefully it is not significant!
anova(M2, M3)
NoiseEps <- rnorm(N, mean = 0, sd = 0.4)
a1 <- rnorm(20, mean = 0, sd = 0.1)
a  <- rep(a1, each = 15)
RE <- rep(1:20, each = 15)
eta <- alpha + beta * X + a + NoiseEps
mu  <- exp(eta)
Y2  <- rpois(N, lambda = mu)
plot(x=X, y = Y2)
plot(Y,Y2)
plot(Y1,Y2)
plot(x=X, y = Y2)
plot(Y,Y2)
plot(Y1,Y2)
#Now apply the random intercept Poisson GLMM on these data.
#This should give an overdispersed model
M4 <- glmer(Y2 ~ X + (1|RE), family = poisson)
summary(M4)
#Plot fitted values versus residuals
plot(residuals(M4) ~ fitted(M4))
#Add smoother
rvec <- seq(0,30,length=101)
Sm1 <- loess(residuals(M4) ~ fitted(M4))
lines(rvec, predict(Sm1, newdata = rvec), col = 2, lwd = 2)
abline(h = 0)
E4 <- resid(M4, type = "pearson")
p4 <- length(fixef(M4)) + 1
sum(E4^2)/(N-p4)
#Now...if we fit the random intercept Poisson GLMM with extra dispersion
#parameter, we get:
M5 <- glmer(Y2 ~ X + (1|RE) + (1|Eps) , family = poisson)
summary(M5)
E5 <- resid(M5, type = "pearson")
p5 <- length(fixef(M5)) + 2
sum(E5^2)/(N-p5)
#Compare the last two models:
anova(M4, M5)
#Subsection 2.4.4
Eps <- 1:nrow(Owls2)
M2 <- glmer(NCalls ~ SexParent * FoodTreatment +
SexParent * ArrivalTime +
offset(LogBroodSize) +
(1| Nest) + (1|Eps),
family = poisson, data = Owls2)
M1 <- glmer(NCalls ~ SexParent * FoodTreatment +
SexParent * ArrivalTime +
offset(LogBroodSize) +
(1| Nest),
family = poisson, data = Owls2)
anova(M1,M2)
#Function to convert a vector into a matric for 2-way nested GLMMs
Vec2Mat <- function(FNest, FY){
AllNests <- levels(FNest)
NNest <- length(unique(FNest))
MaxObs <- max(table(FNest))
Y.ij <- matrix(NA,nrow=MaxObs, ncol= NNest)
for (i in 1:NNest) {
Selection <- FNest==AllNests[i]
ni <- sum(Selection)
Y.ij[1:ni,i] <- FY[Selection]
}
Y.ij
}
Mat2Vec <- function(NumInNest, FY){
nc <- ncol(FY)
N <-  sum(NumInNest)
Y <- vector(length = N)
a1 <- 1
for (i in 1:nc) {
a2 <- a1 + NumInNest[i] -1
Y[a1:a2] <- FY[1:NumInNest[i],i]
a1 <- a1 + NumInNest[i]
}
Y
}
NCalls.ij           <- Vec2Mat(Owls2$Nest, Owls2$NCalls)
ArrivalTime.ij      <- Vec2Mat(Owls2$Nest, Owls2$ArrivalTime-mean(Owls2$ArrivalTime))
LBroodSize.ij       <- Vec2Mat(Owls2$Nest, Owls2$LogBroodSize)
SexParent.ij        <- Vec2Mat(Owls2$Nest, Owls2$SexParent)
iSexParent.ij       <- SexParent.ij -1
FoodTreatment.ij    <- Vec2Mat(Owls2$Nest, Owls2$FoodTreatment)
iFoodTreatment.ij   <- FoodTreatment.ij - 1
Owls2$Cen.AT <- Owls2$ArrivalTime-mean(Owls2$ArrivalTime)
NObservationsInNest <- as.numeric(tapply(Owls2$NCalls, FUN = length, INDEX = Owls2$Nest))
#Bundle data
win.data <- list(NCalls             = NCalls.ij,
ArrivalTime         = ArrivalTime.ij,
LBroodSize          = LBroodSize.ij,
NNest               = length(levels(Owls2$Nest)),
NObservationsInNest = NObservationsInNest,
iSexParent          = iSexParent.ij,
iFoodTreatment      = iFoodTreatment.ij)
#####################################
#Model
# The code below contains slightly more things than in the
# book, e.g. the Pearson residuals etc.
sink("modelglm.txt")
cat("
model{
#Priors
for (i in 1:5) { beta[i]  ~ dnorm(0, 0.001) }
alpha ~ dnorm(0, 0.001)
#Likelihood
for (i in 1:NNest) {
for (j in 1:NObservationsInNest[i]) {
NCalls[j,i] ~ dpois(mu[j,i])
log(mu[j,i]) <- max(-20, min(20, eta[j,i]))
eta[j,i] <- alpha + beta[1] * iSexParent[j,i] +
beta[2] * iFoodTreatment[j,i] +
beta[3] * ArrivalTime[j,i] +
beta[4] * iFoodTreatment[j,i] * iSexParent[j,i] +
beta[5] * iSexParent[j,i]     * ArrivalTime[j,i] +
1 * LBroodSize[j,i]
#Discrepancy measures
YNew[j,i] ~ dpois(mu[j,i])
PRes[j,i]    <- (NCalls[j,i] - mu[j,i]) / sqrt(mu[j,i])
PResNew[j,i] <- (YNew[j,i] - mu[j,i]) / sqrt(mu[j,i])
D[j,i]     <- pow(PRes[j,i], 2)
DNew[j, i] <- pow(PResNew[j,i], 2)
}
Fiti[i] <- sum(D[1:NObservationsInNest[i], i])
FitiNew[i] <- sum(DNew[1:NObservationsInNest[i], i])
}
Fit <- sum(Fiti[1:NNest])
FitNew <- sum(FitiNew[1:NNest])
}
",fill = TRUE)
sink()
#Inits function
inits  <- function () {
list(
alpha      = rnorm(1),
beta       = rnorm(5))  }
#Parameters to estimate
params <- c("alpha","beta", "PRes", "Fit", "FitNew")
#MCMC settings
nc <- 3           #Number of chains
ni <- 100000       #Number of draws from posterior (for each chain)
nb <- 10000         #Number of draws to discard as burn-in
nt <- 100           #Thinning rate
library(R2WinBUGS)
#Start Gibbs sampler
out1 <- bugs(data = win.data,
inits = inits,
parameters = params,
model = "modelglm.txt",
n.thin = nt,
n.chains = nc,
n.burnin = nb,
n.iter = ni,
debug = FALSE)
print(out1, digits = 2)
#Section 2.6.7
Chains <- out1$sims.array[,, beta[1]]
plot(x=X, y = Y2)
plot(Y,Y2)
plot(Y1,Y2)
rep(1:20, each = 15)
#Now apply the random intercept Poisson GLMM on these data.
#This should give an overdispersed model
M4 <- glmer(Y2 ~ X + (1|RE), family = poisson)
summary(M4)
#Plot fitted values versus residuals
plot(residuals(M4) ~ fitted(M4))
#Plot fitted values versus residuals
plot(residuals(M4) ~ fitted(M4))
#Add smoother
rvec <- seq(0,30,length=101)
Sm1 <- loess(residuals(M4) ~ fitted(M4))
lines(rvec, predict(Sm1, newdata = rvec), col = 2, lwd = 2)
abline(h = 0)
seq(0,30,length=101)
lines(rvec, predict(Sm1, newdata = rvec), col = 2, lwd = 2)
abline(h = 0)
E4 <- resid(M4, type = "pearson")
p4 <- length(fixef(M4)) + 1
sum(E4^2)/(N-p4)
NoiseEps <- rnorm(N, mean = 0, sd = 1.4)
a1 <- rnorm(20, mean = 0, sd = 0.1)
a  <- rep(a1, each = 15)
RE <- rep(1:20, each = 15)
eta <- alpha + beta * X + a + NoiseEps
mu  <- exp(eta)
Y2  <- rpois(N, lambda = mu)
plot(x=X, y = Y2)
plot(Y,Y2)
plot(Y1,Y2)
#Now apply the random intercept Poisson GLMM on these data.
#This should give an overdispersed model
M4 <- glmer(Y2 ~ X + (1|RE), family = poisson)
summary(M4)
#Plot fitted values versus residuals
plot(residuals(M4) ~ fitted(M4))
#Add smoother
rvec <- seq(0,30,length=101)
Sm1 <- loess(residuals(M4) ~ fitted(M4))
lines(rvec, predict(Sm1, newdata = rvec), col = 2, lwd = 2)
abline(h = 0)
#Add smoother
rvec <- seq(0,90,length=101)
Sm1 <- loess(residuals(M4) ~ fitted(M4))
lines(rvec, predict(Sm1, newdata = rvec), col = 2, lwd = 2)
abline(h = 0)
E4 <- resid(M4, type = "pearson")
p4 <- length(fixef(M4)) + 1
sum(E4^2)/(N-p4)
openxlsx::write.xlsx(Owls2, "Owls2.xlsx")
names(Owls2)
M1 <- glmer(NCalls ~ SexParent * FoodTreatment +
SexParent * ArrivalTime +
offset(LogBroodSize) +
(1| Nest),
family = poisson, data = Owls2)
sjPlot::tab_model(M1)
library(emmeans)
emmeans(M1)
emmeans(M1, "Male")
emmeans(M1, "SexParent")
emmeans(M1, c("SexParent","FoodTreatment"))
sp.oats <- read.csv("oats.csv")
sp.oats <- within(sp.oats,nitroF <- factor(nitro))
head(sp.oats)
library(lattice)  # Can only list one package at a time
library(car)
library(agricolae)
with(sp.oats,xyplot(yield~nitroF|variety))
with(sp.oats,xyplot(yield~nitroF|variety))
with(sp.oats,xyplot(yield~nitroF|variety,groups=replicate))
with(sp.oats,xyplot(yield~nitroF|variety,groups=replicate,aspect="xy"))
with(sp.oats,xyplot(yield~nitroF|variety,groups=replicate,aspect="xy",type="o"))
with(sp.oats,xyplot(yield~nitroF|variety,groups=replicate,aspect="xy",type="a"))
res.bad <- lm(yield~variety*nitroF,data=sp.oats)
anova(res.bad)
res.good <- aov(yield~variety*nitroF+Error(replicate:variety),data=sp.oats)
summary(res.good)
emmeans(M1, c("SexParent","FoodTreatment", "Satiated"))
emmeans(M1, c("SexParent","FoodTreatment", "ArrivalTime"))
emmeans(M1, c("SexParent","FoodTreatment", "ArrivalTime[24,28]"))
emmeans(M1, c("SexParent","FoodTreatment", "ArrivalTime"))
library(xfun)
remove.packages("xfun", lib="~/R/win-library/4.1")
install.packages("xfun")
install.packages("xfun")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
library(tidyverse)
as_tibble(DF)
DF <- data.frame(Col1 = 1:5,
Col2 = c("Sit1","Sit1","Sit2","Sit2","Sit3"),
Log = c(T,T,F,F,T),
Fct = factor(c("A","B","C","B","A")))
as_tibble(DF)
TB <- tibble(Col1 = 1:5,
Col2 = c("Sit1","Sit1","Sit2","Sit2","Sit3"),
Log = c(T,T,F,F,T),
Fct = factor(c("A","B","C","B","A")))
TB
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")colorPal <- c("#b41214","#007588","#ffc000")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
primeraLista <- list(TB = TB, DF = DF, vec = vector1, factor = F2)
primeraLista
primeraLista <- list(TB = TB, DF = DF, vec = vector1, factor = F2)
primeraLista
primeraLista <- list(TB, DF, vector1, F2)
primeraLista
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
primeraLista <- list(TB = TB, DF = DF, vec = vector1, factor = F2)
primeraLista
TB <- tibble(Col1 = 1:5,
Col2 = c("Sit1","Sit1","Sit2","Sit2","Sit3"),
Log = c(T,T,F,F,T),
Fct = factor(c("A","B","C","B","A")))
TB
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
TB <- tibble(Col1 = 1:5,
Col2 = c("Sit1","Sit1","Sit2","Sit2","Sit3"),
Log = c(T,T,F,F,T),
Fct = factor(c("A","B","C","B","A")))
TB
DF <- data.frame(Col1 = 1:5,
Col2 = c("Sit1","Sit1","Sit2","Sit2","Sit3"),
Log = c(T,T,F,F,T),
Fct = factor(c("A","B","C","B","A")))
# Crear un factor con niveles ordenados manualmente
F2 <- factor(vectorC, levels=c("B","C","A"))
# Crear un rango de valores cualquiera
vector1<-1:10
# Crear un vector de texto cualquiera
vectorC <- c("A","B","A","A","A","A","B","A","C","C","B")
# Crear un factor con niveles ordenados manualmente
F2 <- factor(vectorC, levels=c("B","C","A"))
L2 <- dplyr::lst(TB, DF, vector1, F2)
L2
unlist(L2)
is(unlist(L2))
fix(unlist(L2))
fix(d<-unlist(L2))
fix(d<-unlist(L2);d)
d<-unlist(L2)
fix(d)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::render_book("index.Rmd", "bookdown::gitbook")
colorPal <- c("#b41214","#007588","#ffc000")
colorPal
